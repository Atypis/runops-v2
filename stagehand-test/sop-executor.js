import { Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";
import config from "./stagehand.config.js";
import CredentialManager from "./credential-manager.js";

/**
 * SOP Executor - Executes atomic steps from Stagehand-optimized SOPs
 * 
 * This class takes the atomic steps generated by our giga-optimized prompt
 * and executes them using Stagehand's page.act() and page.extract() methods.
 * Now includes secure credential management for Gmail and Airtable access.
 */
class SOPExecutor {
  constructor() {
    this.stagehand = null;
    this.page = null;
    this.executionLog = [];
    this.variables = {};
    this.credentialManager = new CredentialManager();
    this.credentials = null;
  }

  async init() {
    console.log('ðŸš€ Initializing Stagehand...');
    
    // Create Stagehand configuration by combining our config
    const stagehandConfig = {
      // LLM configuration (top-level properties as expected by Stagehand)
      modelName: config.llmConfig.modelName,
      modelClientOptions: config.llmConfig.modelClientOptions,
      
      // Environment configuration
      env: process.env.BROWSERBASE_API_KEY && process.env.BROWSERBASE_PROJECT_ID ? 'BROWSERBASE' : 'LOCAL',
      
      // Browserbase configuration (if available)
      ...(process.env.BROWSERBASE_API_KEY && process.env.BROWSERBASE_PROJECT_ID ? {
        apiKey: process.env.BROWSERBASE_API_KEY,
        projectId: process.env.BROWSERBASE_PROJECT_ID,
      } : {}),
      
      // Local browser configuration
      ...(!process.env.BROWSERBASE_API_KEY || !process.env.BROWSERBASE_PROJECT_ID ? {
        headless: false,
        devtools: true,
        slowMo: 500,
        localBrowserLaunchOptions: {
          headless: false,
          devtools: true,
          args: [
            '--start-maximized',        // Start maximized
            '--no-first-run',           // Skip first run setup
            '--disable-web-security',   // Allow cross-origin for testing
            '--disable-features=VizDisplayCompositor', // Better visibility
            '--force-device-scale-factor=1', // Consistent scaling
            '--auto-open-devtools-for-tabs', // Ensure DevTools open
            '--new-window',             // Open in new window
            '--activate-on-open',       // Activate window on open (macOS)
          ],
          viewport: {
            width: 1280,
            height: 720,
          },
        }
      } : {}),
      
      // General Stagehand configuration
      verbose: config.stagehandConfig.verbose,
      enableCaching: false, // Disable caching for fresh runs
      domSettleTimeoutMs: 30000,
    };
    
    console.log('ðŸ”§ Stagehand Config:', {
      modelName: stagehandConfig.modelName,
      env: stagehandConfig.env,
      hasApiKey: !!stagehandConfig.modelClientOptions?.apiKey,
      verbose: stagehandConfig.verbose
    });
    
    this.stagehand = new Stagehand(stagehandConfig);
    await this.stagehand.init();
    this.page = this.stagehand.page;
    console.log('âœ… Stagehand initialized successfully');
  }

  async close() {
    if (this.stagehand) {
      await this.stagehand.close();
      console.log('ðŸ”’ Stagehand closed');
    }
    
    // Clear credentials from memory for security
    if (this.credentialManager) {
      this.credentialManager.clearCredentials();
    }
  }

  /**
   * Initialize credentials for SOP execution
   */
  async initCredentials() {
    console.log('\nðŸ” Initializing credentials for SOP execution...');
    this.credentials = await this.credentialManager.getAllCredentials();
    return this.credentials;
  }

  /**
   * Execute a single atomic step from the SOP
   */
  async executeStep(step) {
    const startTime = Date.now();
    console.log(`\nðŸŽ¯ Executing: ${step.label}`);
    console.log(`   Type: ${step.type}`);
    console.log(`   Confidence: ${step.confidence_level || 'not specified'}`);
    
    if (step.stagehand_instruction) {
      console.log(`   Instruction: ${step.stagehand_instruction}`);
    }

    try {
      let result = null;

      switch (step.type) {
        case 'task':
          result = await this.executeTask(step);
          break;
        case 'extract':
          result = await this.executeExtract(step);
          break;
        case 'decision':
          result = await this.executeDecision(step);
          break;
        default:
          console.log(`   âš ï¸  Skipping unsupported step type: ${step.type}`);
          result = { success: true, skipped: true };
      }

      const duration = Date.now() - startTime;
      const logEntry = {
        step: step.id,
        label: step.label,
        type: step.type,
        success: result.success,
        duration,
        result,
        timestamp: new Date().toISOString()
      };

      this.executionLog.push(logEntry);

      if (result.success) {
        console.log(`   âœ… Success (${duration}ms)`);
        if (result.data) {
          console.log(`   ðŸ“Š Data:`, result.data);
        }
      } else {
        console.log(`   âŒ Failed (${duration}ms): ${result.error}`);
      }

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.log(`   ðŸ’¥ Exception (${duration}ms): ${error.message}`);
      
      const logEntry = {
        step: step.id,
        label: step.label,
        type: step.type,
        success: false,
        duration,
        error: error.message,
        timestamp: new Date().toISOString()
      };
      
      this.executionLog.push(logEntry);
      return { success: false, error: error.message };
    }
  }

  /**
   * Execute a task step using page.act()
   */
  async executeTask(step) {
    if (!step.stagehand_instruction) {
      return { success: false, error: 'No stagehand_instruction provided' };
    }

    // Replace variables in the instruction
    const instruction = this.replaceVariables(step.stagehand_instruction);
    
    try {
      await this.page.act(instruction);
      return { success: true, instruction };
    } catch (error) {
      // Try error recovery if available
      if (step.error_recovery && step.error_recovery.length > 0) {
        console.log(`   ðŸ”„ Attempting error recovery...`);
        for (const recovery of step.error_recovery) {
          try {
            await this.page.act(recovery);
            await this.page.act(instruction); // Retry original instruction
            return { success: true, instruction, recovered: true };
          } catch (recoveryError) {
            console.log(`   âš ï¸  Recovery failed: ${recoveryError.message}`);
          }
        }
      }
      throw error;
    }
  }

  /**
   * Execute an extract step using page.extract()
   */
  async executeExtract(step) {
    if (!step.extract_instruction || !step.extract_schema) {
      return { success: false, error: 'Missing extract_instruction or extract_schema' };
    }

    try {
      // Parse the Zod schema string (simplified - in production you'd want proper parsing)
      const schemaStr = step.extract_schema;
      let schema;
      
      // Basic schema parsing for common patterns
      if (schemaStr.includes('senderName') && schemaStr.includes('senderEmail')) {
        schema = z.object({
          senderName: z.string(),
          senderEmail: z.string().email(),
          subject: z.string(),
          bodyText: z.string()
        });
      } else {
        // Fallback to a generic object
        schema = z.object({
          data: z.string()
        });
      }

      const result = await this.page.extract({
        instruction: step.extract_instruction,
        schema: schema
      });

      // Store extracted data in variables
      if (result) {
        Object.assign(this.variables, result);
      }

      return { success: true, data: result };
    } catch (error) {
      throw error;
    }
  }

  /**
   * Execute a decision step
   */
  async executeDecision(step) {
    if (!step.stagehand_instruction) {
      return { success: false, error: 'No stagehand_instruction for decision' };
    }

    try {
      // For decisions, we use extract to get a boolean result
      const result = await this.page.extract({
        instruction: step.stagehand_instruction,
        schema: z.object({
          decision: z.boolean(),
          reason: z.string().optional()
        })
      });

      return { success: true, decision: result.decision, reason: result.reason };
    } catch (error) {
      throw error;
    }
  }

  /**
   * Replace variables and credentials in instructions
   */
  replaceVariables(instruction) {
    let result = instruction;
    
    // Replace extracted variables
    for (const [key, value] of Object.entries(this.variables)) {
      result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);
    }
    
    // Replace credentials if available
    if (this.credentials && this.credentialManager) {
      result = this.credentialManager.replaceCredentials(result, this.credentials);
    }
    
    return result;
  }

  /**
   * Execute a sequence of steps
   */
  async executeSteps(steps) {
    console.log(`\nðŸŽ¬ Starting execution of ${steps.length} steps...\n`);
    
    const results = [];
    for (const step of steps) {
      const result = await this.executeStep(step);
      results.push(result);
      
      // Stop on failure unless it's a skipped step
      if (!result.success && !result.skipped) {
        console.log(`\nðŸ›‘ Stopping execution due to failure in step: ${step.label}`);
        break;
      }
      
      // Small delay between steps
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    return results;
  }

  /**
   * Get execution summary
   */
  getExecutionSummary() {
    const total = this.executionLog.length;
    const successful = this.executionLog.filter(log => log.success).length;
    const failed = total - successful;
    const avgDuration = this.executionLog.reduce((sum, log) => sum + log.duration, 0) / total;

    return {
      total,
      successful,
      failed,
      successRate: (successful / total * 100).toFixed(1),
      avgDuration: Math.round(avgDuration),
      log: this.executionLog
    };
  }
}

export default SOPExecutor; 